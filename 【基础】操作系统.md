[TOC]

## 基础篇——常考十问

### 一、进程和线程的区别

* 进程是资源分配的基本单位。多个进程可以并发执行。

  **进程控制块**（PCB）描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

* 线程是进程的实体，是 CPU 调度和分派的基本单位。一个进程可以有多个线程，它们共享进程资源，可并发执行。

  浏览器中有多个线程 ，如 HTTP 请求线程、时间响应线程、渲染线程等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其他事件。

* 从四个方面区别两者：

  * 拥有资源，进程是资源分配的基本单位，线程不拥有但可以访问隶属进程资源。
  * 调度，线程是独立调度的基本单位，不同进程之间的线程切换，会引起进程切换。
  * 系统开销，创建/撤销进程时，需要资源分配与回收；进程切换时，保存新老进程环境保存与设置，而线程切换只需保存和设置少量寄存器，开销很小。
  * 通信方面，线程间可通过直接读取同一进程中的数据进行通信，进程间通信需要借助 IPC（进程通信机制）。

### 二、进程中线程同步的方式有哪些

同步就是调用函数结束，才会回到调用处；异步则是只要启动就不管它，直接回到原点。

1. 临界区：通过对多线程的串行化来访问公共资源或者一段代码，速度快，适合控制数据访问

2. 事件：用来通知线程有一些事件已发生从而启动后继任务的开始。

3. 互斥量：为协调共同对一个共享资源的单独访问而设计。互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。可实现**不同程序的线程**（跨进程使用）之间对资源的安全共享。

4. 信号量：为控制一个具有有限数量的用户资源而设计。信号允许多个线程同时使用共享资源 ，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。

   

### 三、进程的通信方式有哪些（IPC）

主要分为管道（普通管道PIPE，流管道，命名管道），系统 IPC（消息队列，信号量，共享存储），SOCKET。

1. 管道，通过调用 pipe 函数创建，fd[0] 用于读，fd[1] 用于写。

   * 只支持半双工通信（单向交替传输）
   * 只能在父子进程或者兄弟进程中使用

   ```
   #include<unistd.h>
   int pipe(int fd[2]);
   ```

2. FIFO，也称为命名管道，去掉了管道只能在父子进程中使用的限制，常用与客户-服务器应用程序中，FIFO 作为汇聚点，在客户进程和服务器进程之间传递数据。

3. 消息队列，消息的链表，存放在内核中并由消息队列标识符标识。

4. 信号量，一个计数器，用于为多个进程提供对共享数据对象的访问。也是进程同步与互斥的常用方法。

5. 共享存储，在进程的地址空间映射一段能被其他进程访问的内存。由于数据不需要在进程间赋值，所以这是最快的一种 IPC。需要使用信号量来同步对共享存储的访问。

6. 套接字，可以用于不同机器的进程通信。

### 四、什么是缓冲区溢出？危害？原因？

缓存区溢出指当计算机向缓存区填充数据时超出了缓存区本身的容量，溢出的数据覆盖在合法数据上。

* 危害

  * 程序崩溃，导致拒绝服务
  * 跳转并执行一段恶意代码

* 原因

  程序中没有仔细检查用户输入

### 五、什么是死锁？产生条件？处理基本策略？

两个或多个并发进程，每个进程都持有某种资源且等待其他进程释放他们现在保持着的资源，无限期的阻塞、互相等待的一种状态。

四个条件（缺一不可）——**竞争系统资源，进程推进顺序不当**

* 互斥条件，一个资源只能被一个进程使用
* 占有和等待条件，已经获得某个资源的进程可以再请求新的资源
* 不剥夺条件，进程获得的资源，在未完全使用完之前，不能强行剥夺
* 循环等待条件，若干进程之间形成一种首尾相接的环形等待资源关系

解决方法（按死锁的生命周期考虑）

* 鸵鸟策略，不管它。解决死锁的代价很高，且不会对用户造成大影响时，可采用这种策略获得高性能。

* 预防死锁

  * 资源一次性分配，破坏请求和保持条件；
  * 可剥夺资源，新资源未满足时，释放已占有资源，破坏不可剥夺条件；
  * 资源有序分配法，按序号递增的顺序请求资源，相反顺序释放，破坏环路等待条件。

* 避免死锁

  允许进程动态申请资源，系统在资源分配前预先计算资源分配的安全性，若不安全，则进程等待。如**银行家算法**。

* 检测死锁

  为每个进程和资源指定一个唯一的号码，然后建立资源分配表和进程等待表。有每种类型一个资源的死锁检测算法（检测有向图是否存在环）；每种类型多个资源的死锁检测算法（标记进程）

* 解除死锁

  * 剥夺资源，从其他进程剥夺足够资源给死锁进程
  * 撤销进程，直接撤销死锁进程或代价最小的进程，直到有足够的资源消除死锁状态。
  * 回滚恢复

### 六、进程有哪几种状态？

* 就绪状态：进程已经获取处理机外的所有所需资源，等待被调度
* 运行状态：占用处理机资源运行，处于此状态的进程数小于等于 CPU 数
* 阻塞状态：进程等待某资源，在条件满足前无法执行。该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

就绪 <-> 运行 -> 阻塞 -> 就绪 

### 七、分页和分段有什么区别？

段页式的程序地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分为大小相同的页。既有了分段系统的共享和保护，又拥有分页系统的虚拟内存。

* 对程序员的透明性：分页透明，分段需要程序员显式划分各个段。
* 地址空间的维度：分页是一维地址空间，分段是二维的。
* 大小是否可以改变：页的大小不可变，段的大小可动态改变。
* 出现的原因：分页主要是为了实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间，并有利于共享和保护。

### 八、操作系统中进程调度策略有哪几种？

不同环境的调度算法目标不同，针对不同环境来讨论调度算法。

1. 批处理系统，没有太多的用户操作，调度算法的目的是保证吞吐量和周转时间（从提交到终止的时间）。

   * FCFS（先来先服务），非抢占式的调度算法，有利于长作业，因为短作业会等待时间过长。
   * 短作业优先（SJF），非抢占式，长作业可能会饿死。
   * 最短剩余时间优先（SRTN），抢占式，新作业到达时，运行时间与当前进程的剩余时间作比较，更长的被挂起或等待。

2. 交互式系统，有大量的用户操作，调度算法的目的是快速的进行响应。

   * 时间片轮转，所有就绪队列按 FCFS 原则排一个队列，每个进程执行一个 CPU 时间后，被中断挂起到队尾。时间片太小会导致进程切换花过多时间，过长则不能保证实时性。

   * 优先级调度，为每个进程分配一个优先级。为了防止低优先级进程永远等不到调度，可以随着时间推移增加等待进程的优先级。

   * 多级反馈队列，时间片轮转原则下，设置多个队列，每个队列时间片大小不同，优先级不同。上一个队列没有进程排队，调度当前队列的进程。是前两种调度算法的结合。

3. 实时系统，要求一个请求在确定时间内得到响应，分为软实时和硬实时，前者可以容忍一定超时，后者必须满足绝对的截止时间。

### 九、进程同步有哪几种机制

为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程需要的信息。完成进程和线程的协调。

信号量、管程、互斥量、文件锁

1. **临界区**，对临界资源进行访问的那段代码称为临界区。

   为了互斥访问临界资源，每个进程进入临界区前需要先进行检查。

2. **同步与互斥**

   * 同步，多个进程因为合作关系产生的直接制约关系，使得进程有一定的先后执行关系。
   * 互斥量，多个进程在同一时刻只能有一个进入临界区。

3. 信号量，一个整型变量，可对其执行 down 和 up 操作（PV操作）。

   * down：信号量大于 0，执行 -1 操作；等于 0，进程睡眠
   * up：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

   down 和 up 操作不可分割，通常做法是执行时屏蔽中断。信号量取值为0 1则成为**互斥量**，0 表示临界区加锁，1 表示临界区解锁。

   ```
   //信号量实现生产者-消费者问题:缓冲区没满，生产者可以放入物品；缓冲区不为空，消费者可以拿走物品。
   //empty：空缓冲区 full：满缓冲区；不能先对缓冲区加锁，再测试信号量。
   #define N 100
   typedef int semaphore;
   semaphore mutex = 1;
   semaphore empty = N;
   semaphore full = 0;
   void producer() {
       while(TRUE) {
           int item = produce_item();
           down(&empty);
           down(&mutex);
           insert_item(item);
           up(&mutex);
           up(&full);
       }
   }
   void consumer() {
       while(TRUE) {
           down(&full);
           down(&mutex);
           int item = remove_item();
           consume_item(item);
           up(&mutex);
           up(&empty);
       }
   }
   ```

4. 管程

   使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，管程**把控制的代码独立出来**，不仅不容易出错，也使得客户端代码调用更容易。管程引入**条件变量**以及**wait()** 和 **signal()**来实现同步操作。C 不支持管程。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

   * 一个时刻只能由一个进程使用管程。进程在无法继续执行时不能一直占用管程。



## 查漏补缺篇——概念划分

### 概述

------

#### 1. 基本特征——并发、共享、虚拟、同步

* 并发，**宏观上**一段时间能同时运行多个程序（进程和线程）

  并行指同一时刻运行多个指令（需要硬件支持，多流水线、多核CPU、分布式计算系统）

* 共享，系统资源同时被多个并发进程共同使用。

  两种方式：互斥共享和同时共享。

  互斥共享的资源称临界资源，如打印机等，同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

* 虚拟，虚拟技术把一个物理实体转换为多个逻辑实体。

  两种技术：时（时间）分复用和空（空间）分复用。

  多进程并发——时分复用，每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

  **虚拟内存**——空分复用，将物理内存抽象为地址空间，每个进程有自己的地址空间。地址空间的页被映射到物理内存，但不需要全部在物理内存内，当用到一个没有在物理内存的页时，执行**页面置换算法**，将该页置换到内存中。

* 异步，进程不是一次性执行完，而是走走停停，以不可知的速度推进。

#### 2. 基本功能——进程管理、内存管理、文件管理、设备管理

* 进程管理

  进程控制、进程同步、进程通信、死锁管理、处理及调度等。

* 内存管理

  内存分配、地址映射、内存保护与共享、虚拟内存等。

* 文件管理

  文件存储空间的管理、目录管理、文件读写管理和保护等。

* 设备管理

  缓存管理、设备分配、设备处理、虚拟设备等。

#### 3. 中断分类——外中断、异常、陷入

* 外中断，由 CPU 执行指令以外的事件引起，如 I/O 完成中断，提醒处理器可以发送下一个输入/输出请求。时钟中断、控制台中断等。
* 异常，由 CPU 执行的内部事件引起，地址越界、算术溢出、非法操作码等。
* 陷入，在用户程序中使用系统调用。

#### 4. 系统调用——用户态和核心态

* 一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

####  5. 核心态——大内核和微内核

* 大内核，将操作系统功能作为一个紧密结合的整体放到内核。各模块共享信息，因此有很高的性能。

* 微内核，操作系统不断复杂，于是将一部分操作系统功能移出内核，从而降低内核复杂性。移出的部分根据分层原则划分为若干服务，互相独立，交互都借助于微内核进行通信。

  因为需要频繁的在用户态和核心态之间进行切换，所以会有一定的性能损失。

  为减少切换开销，也有人提出将系统服务作为运行库链接到用户程序的一种解决方案，这样的体系结构称为库操作系统。

### 进程管理

---

#### 1. 进程与线程的区别（基础篇题一）

#### 2. 进程状态的切换（基础篇题六）

#### 3. 进程调度算法（基础篇题八）

#### 4. 进程同步（基础题题九）-------------

#### 5. 进程通信（基础题三）

#### 6. 进程同步、互斥和进程通信的区别

进程同步和进程通信很容易混淆，他们的区别在于：

* 进程同步：控制多个进程按一定的顺序执行。一种目的。
* 进程通信：进程间传输信息。一种手段。

进程互斥是特殊的进程同步，进程同步是一种目的，进程通信是一种手段。为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步需要的信息。

#### 7. 经典同步问题：哲学家进餐问题；读者-写者问题

* 哲学家进餐问题：防止死锁可设置两个条件

  * 必须同时拿起左右两根筷子
  * 只有在两个邻居都没有进餐的情况下才允许进餐

  ```
  #define N 5
  #define LEFT (i + N - 1) % N // 左邻居
  #define RIGHT (i + 1) % N    // 右邻居
  #define THINKING 0
  #define HUNGRY   1
  #define EATING   2
  typedef int semaphore;
  int state[N];                // 跟踪每个哲学家的状态
  semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
  semaphore s[N];              // 每个哲学家一个信号量
  
  void philosopher(int i) {
      while(TRUE) {
          think(i);
          take_two(i);
          eat(i);
          put_two(i);
      }
  }
  
  void take_two(int i) {
      down(&mutex);
      state[i] = HUNGRY;
      check(i);
      up(&mutex);
      down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
  }
  
  void put_two(i) {
      down(&mutex);
      state[i] = THINKING;
      check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
      check(RIGHT);
      up(&mutex);
  }
  
  void eat(int i) {
      down(&mutex);
      state[i] = EATING;
      up(&mutex);
  }
  
  // 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
  void check(i) {         
      if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
          state[i] = EATING;
          up(&s[i]);
      }
  }
  ```

* 允许多个进程同时对数据进行读操作，但是不允许读写以及写写同时发生。

  * 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

  ```
  typedef int semaphore;
  semaphore count_mutex = 1;
  semaphore data_mutex = 1;
  int count = 0;
  
  void reader() {
      while(TRUE) {
          down(&count_mutex);
          count++;
          if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
          up(&count_mutex);
          read();
          down(&count_mutex);
          count--;
          if(count == 0) up(&data_mutex);
          up(&count_mutex);
      }
  }
  void writer() {
      while(TRUE) {
          down(&data_mutex);
          write();
          up(&data_mutex);
      }
  }
  ```

### 死锁

------

#### 1. 死锁的必要条件（基础篇题五）

#### 2. 死锁检测和恢复，预防和避免，银行家算法（基础题五）

### 内存管理

--------

#### 1. 虚拟内存

虚拟内存的目的是让物理内存扩充为更大的逻辑内存，从而使程序获得更多的可用内存。

操作系统将内存抽象为地址空间。每个程序拥有自己的地址空间，地址空间被分割成多个块，每一块为一页。这些页被映射到物理内存，但不需要连续物理内存，或所有页都必须在物理内存中。映射由硬件完成。

#### 2. 分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。首先获取页表的页面号，在相应页表项查找是否存在于内存中，若是，页面号+偏移量=物理地址。

#### 3. 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生**缺页中断从而将该页调入内存中**。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法的主要目标是使页面置换率最低（缺页率最低）。

* 1. 最佳，选择被换出的页面将是最长时间不再被访问的。一种理论上的算法。
* 2. 最近最久未使用（LRU），在内存中维护一个所有页面的链表，一个页面被访问时则移到表头，每次去掉链表表尾。每次都要更新链表，代价很高。
* 3. 最近未使用（NRU），每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。随机地从类编号最小的非空类中挑选一个页面将它换出。优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。
* 4. 先进先出（FIFO），会将经常被访问的页面也换出，缺页率升高。
* 5. 第二次机会算法（FIFO的改进），当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。 R 位是 0则立刻置换掉；如果是 1，就将 R 位清 0，并更新它的装入时间，继续从链表的头部开始搜索。
* 6. 时钟，第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再用一个指针指向最老的页面。

#### 4. 分段

一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

#### 5. 分段与分页的比较（基础篇题七）

### 设备管理

--------

#### 1. 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

#### 2. 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

* 先来先服务（FCFS），按磁盘请求顺序进行调度。公平简单，未对寻道优化，平均寻道时间可能很长。
* 最短寻道时间有限（SSTF），优先调度与当前磁头所在磁道距离最近的磁道。两端的磁道请求更容易出现饥饿现象。
* 电梯算法（SCAN），总保持一个方向运行直到该方向没有请求为止，然后改变运行方向。解决了 SSTF 的饥饿问题。

###  链接

---------

#### 1. 编译系统

一个hello.c 程序：

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将**可重定位目标文件**和 printf.o 等单独预编译好的目标文件进行合并，得到最终的**可执行目标文件**。

#### 2. 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改**所有对这些符号的引用**，使得它们指向这个内存位置。

#### 3. 目标文件

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；

#### 4.动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。







  

