[TOC]

# Java编程思想
## 第一章 对象的概念

* **抽象**

万物皆可对象，对象具有状态、行为和标志（type）。

* **接口**

一个类 class 就是一个数据类型

* **服务提供**

每个对象完成一项服务而不试图做更多的事（一对一）

* **封装**

类创建者和客户端程序员之间的权限边界

public、private、protected以及包访问权限

* **复用**

has-a关系，类内private一个其他类。

* **继承**

类与基类有相同的类型。两种使用场景如下：

替代原则：is-a 是一个

扩展关系：is-like-a 像是一个

* **多态**

子类继承并重写基类方法，对子类的函数调用时，OOP采用后期绑定的概念。即编译器确保被调用方法的存在，并对调用参数与返回值执行类型检查，但是并不知道将被执行的确切代码。java用一小段特殊代码代替绝对寻址调用，默认动态绑定（C++中就不是hh，使用virtual关键字实现）。

子类可被看作它的基类类型的过程称为向上转型（up-casting）。

* **单继承结构**

java所有的类继承于Object，使得每个对象上都可以有一些基本操作，且方便了垃圾回收器。

* **集合Collection**

Java SE5之前，collection中存储的是通用类型Object，即对象存入集合时向上转型为Object，但使用时需要向下转型为具体类型——如果转错了类型，则会出现runtime exception的异常；且互相转型需要额外的运行时间。

javaSE5增加了参数类型，即泛型。标志是尖括号内加包含类型信息。

* **对象创建与生命周期**

java完全采用动态内存分配方式，只能用一种方式创建对象，即使用new关键字，在堆上构建对象的动态实例。

java提供了“垃圾回收器”，自动发现对象何时不被使用并销毁他。

* **异常处理**

java内置了异常处理，在语言级别强制你必须使用它。

但是异常处理不是oop的特征。

* **并发**

语言级别上，程序员不用操心多少个处理器，程序在逻辑上被分为线程，只需要操心共享资源如何分配和释放的问题。

java的并发内置于语言之中，javaSE5添加了大量的内置库支持。

* ** java和因特网**

微软的.NET和C#，.NET平台大致相当于JVM+java类库。

### 小结

OOP（面向对象的编程）用两部分解决问题，即用来表示问题空间概念的对象+发送给这些对象的用来表示在此空间内的行为的消息。

 

## 第二、三章 一切都是对象

* **数组的存储**

新建一个对象数组，实际上创建了一个引用数组，每个引用初始值为null

* **Static**

1、共享存储空间 2、不与特定对象关联，类名直接调用

* **Javadoc**

编写程序时以一套特定的标签做标注，程序完成后可用javadoc生成自己的API文档。

## 第四章 运算符

* **短路**

&& ||等的逻辑判断，左侧已判错时不需要继续走右侧。

* **字面值常量**

* **数字字面量可以加下划线**

* **指数计数法**

e为10的几次幂；编译器会将指数作为double类型处理，float型要靠后缀f区分。

* **位运算符？**

* **移位运算符**

<<低位补零，>>正值高位补0，负值高位补1。 >>>不分正反高位补0。

* **三元运算符？：**

* **字符串运算符+** 

“”+基本数据类型，可隐式地将其转换为字符串，以代替显式的调用

* **类型转换**

向上转换相对安全：不必进行显式类型转换，编译器在必要时会自动提升int的长度为long

向下转换：必须显式。

java不用考虑sizeof来获取数据被分配的字节大小，它跟平台无关鸭hhh

 

## 第五章 控制流

### label的使用

java中唯一需要用到label的情况是在有循环嵌套存在，而想要从多层嵌套中break或continue。

如下情况定义了一个label在循环外，语句为”outer：“

continue outer；则跳到outer位置，重新进入下一行的循环

Break outer；则跳过outer标志，并移离当前标签的末尾

## 第六章 初始化和清理

不初始化的结果：空指针的产生原因；

不清理的结果：元素使用的资源不被及时释放，导致程序消耗所有的资源（尤其是内存）

C++引入构造器进行初始化，java采用了构造器的概念，同时引入了垃圾回收器自动回收资源。

* **利用构造器保证初始化**

  构造器方法在初始化过程中被自动调用，与类名相同

  编译器不允许有构造器以外的方法创建类对象。

  java中，对象的创建和初始化是统一的概念，两者不可分割。

  构造器和void方法类似又互相区别，普通方法返回值有接受者，构造器没有。

* **方法重载**

  通过类名、参数类型列表、参数顺序，区别重载方法（返回值的重载是行不通的）

  传入的参数类型大于方法期望接收的参数类型，必须首先做下转换。

* **无参构造器**

  若无显式代码，则编译器自动创建无参构造器

  若有自定义构造器，无论是否有参，编译器都不再提供默认构造器

* **this关键字**

  在方法内部，获得对当前对象的引用。

  this只能在**非静态方法**中使用。

* **在构造器中调用构造器**
  只能调用一次，且必须首先调用构造器。
  
  不允许在构造器之外的方法中调用构造器方法。
  
* **static的含义**
  static方法不能访问非静态方法（反之可以）
  
* 垃圾回收器
	* **finalize（）的用途**
	* **必须实施清理**
	* **终结条件**
	* **垃圾回收器如何工作**
	停止-复制，标记-清扫
	* **成员初始化**
		方法的局部变量必须初始化（否则编译时错误）
		类的成员变量会被默认初始化
	
* **构造器初始化**
	在类中变量定义的顺序决定了它们初始化的顺序。

	即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。

* **静态数据初始化**
	static只能用于属性（不能用于局部变量）

	静态数据初始化只会在首次加载class对象时初始化一次。

* **显式的静态数据初始化**
	一组静态初始化动作放在类里面一个特殊的"静态子句"（有时叫做静态块）中，如下：
	static{}

* **非静态实例初始化**
	在一个关键字后面的一段初始化代码块，如下：

```java
	Student student；
	{System.out.println("initialized");}
```

​	**在构造器之前执行，**即每创建一个新的对象，该段代码运行一次。

* **数组初始化**
	数组以{}初始化内容，或new初始化大小（动态初始化）；
	
	数组元素为类对象时，直到每个数组内容都被创建了对象为止，才是初始化结束；否则依旧是引用数组
	
	可变参数列表

	`sout`默认打印类名和对象的地址。
	
	`f(Integer…args);f（4，5，6，7);`

	防止重载无参f：给方法添加非可变参数（类似标记符作用）

* **枚举类型**
switch在有限可能值集合中选择，和enum是绝配！

### 小结

在不需要类似析构器行为的时候，java的垃圾回收器极大地简化了编程，并加强了内存管理的安全。但是，垃圾回收器确实增加了运行时开销。

## 第七章 封装

### 包的概念

包内的类互相访问， **import**某个包下全部类，import xxx.*。

一个java源代码文件称为一个编译单元，文件名后缀为.java。在编译单元中可以且只能有一个public类，类名必须与文件名相同。如果此编译单元中包含其它类，那么在包以外则无法访问到这些类，因为他们不是public类，此时他们支持public类。

### 代码组织

编译一个.java文件后每个类都会有一个输出文件，.class文件，一组.class文件打包压缩成一个java文档文件（.jar，使用jar文档生成器）。java解释器负责查找、加载和解释这些文件。

类库是一组类文件，每个源文件包含一个public类和任意数量的非public类（你硬要不包含public类也行，这时候可以随意命名源文件），因此每个文件都有一个构件（每个都有自己独立的.java和.class文件。），使用**关键字****package**使这些构件从属于同一个群组。

Package xxx； 声明该编译单元是xxx类库的一部分。

package和import关键字允许类库设计员将单一的全局名字空间分隔开，解决名字冲突问题。

### 创建独一无二的包名，classpath+包名检索位置

Import static

import发布版和调试版来实现调试功能的开启和关闭。

创建一个包时，包名隐含了目录结构；这个包必须位于包名指定的目录，且该目录能被classpath开始的目录中查询到（**包名对应目录路径**）。收到运行时错误如找不到特定的类但是该类位于同一目录下，尝试注释掉package目录，如果能运行那就是没有遵循“包名对应目录路径”原则。

编译过的代码通常和源代码在不同目录下（通常由IDE完成）。

**必须保证****jvm****能通过****CLASSPATH****找到编译后的代码。**

### 访问权限控制符

#### public

类名前没有修饰符，为默认包访问权限（此时在包外引用该类/类中没有public的方法就不能！）。一个编译单元只能属于一个包，所以通过包访问权限，同一编译单元中的类可以互相访问到。

类只能是public或者默认包访问权限。

取得对成员访问权的唯一方式：

1、使成员为public，那么包内包外都能访问到。

2、赋予成员默认包访问权限，同时将访问者类放到包内，这样访问者可以访问到该成员。

3、继承的类既可以访问public，又可以访问protected。只有两个类在同一个包里才能访问到包访问权限的成员。

4、提供get和set方法。（访问器和修改器）

同一目录下的类文件**如果没有给自己设定明确的包名**，java把这样的文件看作隶属于该目录的**默认包**中。

#### Private 自己隔离自己

通过private构造器，可以控制如何创建对象（

1、**在类的****static****方法中创建一个对象并返回引用** 

2、设计模式中的单例模式，static private一个静态对象，用户需要访问它时通过public static方法返回其引用。只允许创建类的一个对象。

防止别人直接访问某个特定的构造器。

#### Protected：继承访问权限

protected也提供包访问权限，相同包内的其他类可以访问protected。

protected，即基类的某个成员**能被特定继承类**访问，不能被其他类访问。记录这样一种情况，基类中一个没有修饰符的方法，则在包外的子类中也存在该方法，但是无法访问，因为没有修饰符即默认包访问权限。

#### 包访问权限VSpublic权限

在一个具有包访问权限的类中，定义一个public构造器，并不能使这个构造器变成public（就是说它在包外访问不到的哦）。

### 接口和实现

封装：把数据和方法包装进类里，并把具体实现隐藏称为封装，其结果是一个同时带有数据和行为的数据类型。

访问控制在数据类型内部划定了边界的原因：

1. 确立客户端成员可以使用和不可使用的边界。

2. 将接口和实现分离。

一种创建类的风格：public、protected、包访问权限成员、private成员。（类的使用者可从头读）

## 第八章 复用

复用别人代码的两种方式：

1. 组合，在新类中创建已有类的对象

2. 继承，创建现有类类型的新类。

### 组合语法

每个非基本类型的对象都有一个toString（）方法，当编译器需要一个String而你只有一个对象时，该方法被调用。@Override 注释告诉编译器，以保证正确覆盖。（这个字段有助于验证是否有拼写错误）。类中的基本类型字段初始化为0，对象引用被初始化为null，打印null就不会出错。

初始化引用的四种方法：

1. 在定义对象的地方，这意味着它们总在构造器被调用前初始化。

2. 类的构造器中。

3. 正要使用这些对象之前，即惰性初始化。

4. 使用实例初始化。（类中的无名称代码块，在构造器之前运行）

### 继承语法

使用关键字extends后跟基类的名称实现继承。自动获得基类中的所有字段和方法。

### 小结

如果把项目视作一个有机的，进化着的生命去培养，而不是视为像摩天大楼一样快速见效，就能获得更多的成功和更迅速的反馈。继承和组合正是可以让你执行如此实验的面向对象编程中最基本的两个工具。

 

## 第九章 多态

数据抽象、继承、多态——OOP的三个特性。多态就是把改变的事物和不变的事物分离的技术。

多态又称动态绑定、后期绑定、运行时绑定。

### 向上转型

一个对象可被视为它的自身类型或者基类类型。把一个对象引用当做它的基类引用的做法叫做向上转型。

在向上转型的过程其实就是忘记对象本身类型的过程。

### 方法调用绑定

-----

将一个方法调用和方法主体关联起来称为绑定。

* **前期绑定：**绑定发生在程序运行前（如C语言；实现方法由编译器和链接器实现）

* **后期绑定（动态绑定、运行时绑定）**：方法体在运行时根据对象类型进行绑定。编译器依旧不知道对象的类型，由方法调用机制保证找到正确的方法体并调用。

java中除了static和final方法（private方法也是隐式final）外，**其他方法都是动态绑定**，即自动动态绑定。

**final关键字**：

* 修饰类：该类不能被继承，其中所有成员方法都会被隐式指定为final。

* 修饰方法：该方法不能被继承类重写 起到了1、锁定方法作用2、效率，以前final方法会被转为内嵌调用，在最近版本的java中不需要这个操作来优化程序了。

* 修饰变量：final成员变量表示常量，只能被赋值一次，赋值后不可修改。表示该参数只读。

`final`修饰成员变量（属性），必须显式初始化，1、定义时即初始化 2、在所有的构造方法中初始化它

`final`指向的对象不可更改，但是对象的内容可以修改。把对象指明为final除了防止方法被重写外，也有效地关闭了动态绑定。但是尽量不要为了提高效率把对象定为final。

**向上转型的例子（产生正确的行为（找对代码块）、可扩展性）**

​	创建一个子类对象，引用被赋值给基类类型的变量，如Shape s=new Circle（）。在继承上可认为Circle就是一个Shape。这里的基类可以向上转多层。如Instruments->Wind->Woodwind，Instruments I = new Woodwind() 是对的。

随机生成形状的例子，可以从通用的基类中派生出新的数据类型，从而添加新的功能。那些**操纵基类方法的接口不需要改动就可以应用**于新类。

**常错点一、私有方法不能被重写的**

基类中的private方法，是隐式final，不能被子类继承的。因此在子类中“重写”名字一样的函数，可不是真正的重写哦。此时在基类对象（被赋值了一个子类对象的引用），调用func时依旧调用的基类自身的原方法。

解决方法为养成良好的代码习惯，在写子类的func时，使用@override注释。编译器会报错。

**常错点二、属性不多态**

子类对象被向上转型为基类引用时，任何属性访问都被编译器解析，因此不是多态的，自我理解是未被覆盖的、多份的。（换句话说就是Shape s=new Circle（），shape和circle类中有同名int field。这个s如果直接对field，输出的是基类的field值。但是如果Circle c = new Circle（），c输出的就始终是子类的field，除非显式调用super.field。另外，两种情况下如果调用override的getField方法，那输出的肯定就是子类的field值，因为动态绑定啊！

**常错点三、静态方法行为不具有多态性**

同二，子类中“重写”了基类中同名的static方法，你加个@override试试，肯定报错。

静态方法只和类关联，与单个的对象无关。

### 构造器和多态

--------

构造器不具有多态性哦（它们实际上是隐式声明的静态方法）！

#### 构造器的调用顺序

在派生类的构造过程中都会调用基类的构造器。初始化会自动按继承层次上移（构造器检查对象是否正确构造，基类构造器也要初始化自己的数据鸭）。如果派生类的构造器中没有显式调用基类构造器，编译器默认调用无参构造器，如果没有无参构造器，编译器就报错hhh上一章学过吧，你不写，它造一个，你造了，就是你的责任了）。

关于调用顺序我有话！上段说按继承层次上移是寻找，执行应该是从最高层基类构造器-基类构造器-子类私有属性初始化如果有的话-子类构造器。

1. 基类构造器被调用，这个步骤重复递归直到最高层。

2. 按声明顺序初始化成员。

3. 最终调用派生类的构造器。

代码初始化顺序：

1. 在所有执行开始之前，分配给对象的内存空间被初始化为0.

2. 基类 static 代码块，派生类 static 代码块，基类数据成员（按声明顺序）、基类没名字的代码块，基类构造器，派生类数据成员，派生类没名字的代码块，派生类构造器。

#### 继承和清理

dispose（）调用顺序和构造器方向相反，从子类开始坍塌。成员对象销毁顺序与初始化顺序相反，以防一个依赖另外一个。属性则需与声明顺序相反。

使用static long counter& final long id = counter++实现计数器，为每个对象赋予unique id。

在基类的构造器中调用了动态绑定的方法，在初始化时执行基类的构造器时会调用子类的重写方法，但是此时子类的数据没有被初始化过，只有上段中“分配的内存空间被初始化为0”，因此，重写方法中的指针为null，任何数据成员数值都为0。

引申——构造器应尽量简洁，如果有可能尽量不要调用类中任何方法，需要的话调用final（不能被重写的）或private（默认为final）。

#### 协变返回类型

Java5引入的协变返回类型，允许派生类的被重写方法可以**返回基类方法返回类型的派生类型**。

#### 灵活使用继承和组合

组合不会强制设计师继承层次结构，且组合更加灵活，因为可以动态选择类型，而继承要求在编译时知道确切类型。

例如，Stage对象包含了一个Actor引用，Actor是一个基类，引用可以在运行时与其他不同的对象绑定，即a由HappyActor，被替换成SadActor的引用，这样使用者就获得了运行时的动态灵活性（被称为状态模式）。但是呢，我们不能在编译时决定继承不同对象hh。

通用准则——使用继承表达行为的差异，使用属性表达状态的变化。

#### 替代VS扩展

纯粹的替代（派生类中完全重写基类方法且不增加别的），意味着派生类可以完美替代基类，即可以不考虑具体类型使用向上转型，所有的一切通过多态进行处理。即is-a关系。

但是but! 派生类is-like-a基类，有着相同的基本接口，但也需要额外的方法实现其他特性。

向上转型意味着丢失具体的类型信息，无法通过基类对象调用到这些新方法。

#### 向下转型

向上转型永远是安全的，因为基类不可能比派生类有更多的接口。

而向下转型，必须有某种方法保证其安全，防止意外转型到一个错误类型，进而发送对象无法接收到的信息。

在java中，每次转型都会被检查。ClassCastException-RTTI的行为。

### 小结

多态是一种不能单独看待的特性，与其他特性一起在类视图中被考虑。

## 第十章 接口

接口和抽象类在java中被提供了直接支持（像C++只对这些概念有间接支持）。

两个原则：尽可能的抽象——因此更倾向于使用接口而非抽象类。优先使用普通类而非接口。

### 抽象类

一种介于普通类和接口之间的折中方法。对于创建具有属性和未实现方法的类，抽象类是重要且必要的工具。创建抽象类是为了通过通用接口操纵一系列类。

java提供了抽象方法机制，该方法只有声明没有方法体：abstract void f();

包含抽象方法的类叫抽象类。

如果类包含一个或多个抽象方法，类本身也需被限定为abstract。

如果创建一个继承抽象类的新类的对象，新类必须为基类**所有****abstract****方法**提供定义（最好在定义前加@override，提示该方法被覆写）。若否，则新类被强制为abstract class。

抽象类不能被直接创建对象（new对象）。

骚操作：把一个不包含任何抽象方法的类定义为abstract，可防止该类被创建实例对象。但是依旧可以用基类变量保存一个派生类的引用。

### 接口

使用 interface 关键字创建接口。和类一样，interface 前加上 public 关键字（只有在接口名和文件名相同时），否则接口只有包访问权限。接口中的方法可以显式定义为public（但是你不这样写，它们依旧是public的）；实现接口时，来自接口中的方法必须被定义为public，否则它们只有包访问权限——在继承时，他们的可访问性被降低。

Java8之前的接口，只允许抽象方法。Interface 关键字产生一个完全抽象的类，即只提供形式，没有提供任何实现。

Java8允许接口包含静态方法和默认方法。接口的概念依旧介于类型之上，实现之下。

接口可以包含属性，被隐式指明为static和final。

### 默认方法

在抽象类中，方法前加 default 关键字，该方法带方法实现。默认方法有时被称为守卫方法或虚拟扩展方法。

编译器通过方法签名（包括方法名和参数类型）区分方法——因此可以结合多个源的实现，只要基类中的方法名和参数列表不同即可。当然，返回值类型不能用以区分方法，此时可以通过派生类中覆写原方法的方法解决冲突。

### 接口中的静态方法

Static 关键字修饰的方法——一种应用为模板方法设计模式中的的一个版本，void static runOps(Operations… op){}为一个模板方法；使用了一个可变参数列表。如：Operations.runOps(new Bing(), new Crack(), new Twist()); 

### 抽象类和接口

接口和抽象类最大的区别可能是使用上的惯用方式。接口的典型使用是类的类型或形容词，如 Runnable 或 Serializable；而抽象类通常作为类视图的一层或一部分或事物的属性，如String。

1、一个类可组合多个接口，只能继承一个抽象类（可以向下继续被继承）。

2、接口中不能包含属性（除了静态属性，不支持对象状态），抽象类可以包含属性。

3、不需要在子类中实现接口的默认方法，默认方法可以引用其他接口的方法；抽象类必须在子类中实现抽象方法。

4、接口没有构造器；抽象类可以有构造器。

5、接口为隐式的public，抽象类可以是protected或友元。

### 完全解耦

**策略设计模式**：创建一个能根据传入参数类型不同而具备不同行为的方法，方法包含算法中不变的部分，策略包含变化的部分，策略就是传入的对象，它包含要执行的代码。

协变类型

### 多接口结合

一个类implements多个接口，extends一个类，可向上转型为多个基类型。（使用接口另一个原因是防止客户端程序员创建这个类的对象）

应该使用接口还是抽象类？如果创建不带任何方法定义或成员变量的基类，就选择基类而不是抽象类。

### 使用继承扩展接口

接口可以通过extends扩展接口，这时候extends后可以接多个基类接口哈哈哈哈哈骚操作。

重载方法仅根据返回类型区分不了！！！！！！！

### 接口适配（十八章字符串回看）

相同的接口可以有多个实现，在简单情况下体现在一个方法接受接口作为参数，该接口的实现和传递对象给方法。

创建新类实现Readable接口，可使Scanner作用于它。

### 接口字段

接口中的字段自动static final，所有成员自动public，所以接口成为创建一组常量的方便工具。Java5之前，用这种方法产生enum效果。

接口中定义的字段不能是“空final”，但可以用非常量表达式初始化。

### 接口和工厂方法模式

接口是多实现的途径，工厂设计模式——不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现——理论上，通过这种方法将接口与实现的代码完全分离，使得可以透明的将一个实现替换成另一个实现。

额外的间接层的原因之一——创建框架。

### 小结

有必要时再使用接口和工厂。以需求驱动设计而不是追求奇技淫巧的过早的设计优化。

恰当的原则是优先使用类而不是接口，从类开始，如果使用接口的必要性变得很明确，就重构。

 