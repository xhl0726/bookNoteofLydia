[TOC]

# 计算机网络

## 基础篇--一开始话真多的十二题

### 一、请简述 TCP/UDP 的区别

运输层，主要任务是向用户提供可靠的端到端的差错和流量控制，保证报文的正确运输。

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

区分：

* TCP 面向连接，UDP无连接。
* TCP提供可靠的服务，具有顺序控制，重发控制等机制，可以为应用提供可靠运输。UDP尽最大努力的数据传输服务（不保证可靠交付）。但是UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低，对实时应用很有用，如 IP 电话。
* TCP数据传输速度慢，UDP 数据传输快，主要用于对高速传输和实时性要求较高的通信或广播通信。如 IP 电话。。
* TCP 面向字节流（TCP将数据看作一连串无结构的字节流），UDP面向报文。
* TCP 连接只能是点到点，UDP 支持一对一，一对多，多对一，多对多。
* TCP 首部开销 20 字节，UDP首部开销只有 8 字节。
* TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道。

### 二、请简单说一下你了解的端口及对应的服务

物理意义上端口，如交换机、路由器用于连接其他网络设备的接口等。

逻辑意义上的端口，一般指TCP/IP 协议中的端口，端口号范围0到65535，用于浏览网页服务的80端口，用于FTP服务的21端口等。

按端口号分布划分有知名端口（0-1023，一般固定分配给一些服务），如25端口分配给SMTP （简单邮件传输协议）服务，**80 端口分配给 HTTP 服务**等。动态端口，1024-65535，一般不固定分配，运行的程序向系统提出访问网络的申请，系统分配一个端口号。**MySQL数据库服务 3306端口**。

按协议类型划分有TCP、UDP、IP、ICMP等端口。TCP端口即传输控制协议端口，需要在客户端和服务器间建立连接，包括FTP 服务的21 端口，**Telnet （远程登录）服务的23 端口**，SMTP 服务的 25 端口，以及 HTTP 服务的80 端口等。UDP 端口即用户数据报协议端口，无需建立连接，常见有**DNS （域名服务器）服务的53端口**，SNMP服务的161端口，QQ 使用的8000和4000端口等。

### 三、TCP 的三次握手四次挥手

三次握手即建立 TCP 连接时，需要客户端和服务器总共发送三个包以确认连接的建立。（three-way handshake，三报文握手，不是握手三次，但是普遍理解且称呼的都是三次握手，所以知道就好）在这过程中，双方通过**维护一个序列号**，建立可靠连接。

A 为客户端，B 为服务器端。

* B 处于 LISTEN(监听)状态，等待客户的连接请求。
* A 向 B 发送连接请求报文，SYN=1，ACK =0，选择一个初始的序号 x 。
* B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择了一个初始的序号y。
* A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1 。
* B 收到 A 的确认后，连接建立。

客户端发送的请求如果在网络中滞留，那么隔很久才会收到服务器发回的连接确认。由于三次握手的存在，客户端会忽略服务器的二次请求，不重复打开连接。

服务器发送第二次握手的请求长期没有回应，会**释放相关资源**。此时在另一端，客户端迟迟收不到回应，会再次发送连接请求。

四次挥手：

* A 发送连接释放报文，FIN =1。
* B 收到后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但 A 不能向 B 发送数据。
* 当 B 不再需要连接时，发送连接释放报文，FIN =1。
* A 收到后发出确认，进入 TIME_WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
* B 收到 A 的确认后释放连接。

**四次挥手的原因**：

客户端发送了 FIN 连接释放报文后，服务器收到这个报文，进入 CLOSE-WAIT 状态。这个状态是为了让服务器发送还未传送完毕的数据，**传送完毕后**，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

三次挥手时，客户端没有直接释放连接，而是等待 2MSL，原因有二：

* 确保最后一个确认报文能够到达，如果 B 没收到 A 发送来的确认报文，会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况。
* 等待一段时间是为了让本连接持续时间内所产生的报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### 四、有哪些私有（保留）地址

* A类：`10.0.0.0 - 10.255.255.255`是私有地址，`127.0.0.0-127.255.255.255`是保留地址，用作循环测试使用。

* B类：`172.16.0.0 - 172.31.255.255`是私有地址，`169.254.0.0-169.254.255.255`是保留地址，如果你的 IP 地址是自动获取 IP 地址，而在网络上又没有找到可用的 DHCP 服务器，这是将在`169.254.0.1-169.254.255.254`中临时获得一个 IP 地址。

* C类：`192.168.0.0 - 192.168.255.255`是私有地址。

私有 IP 地址是一段保留的 IP 地址，只使用在局域网中，无法在公网使用。

### 五、 IP 地址分为哪几类？简单说下各个分类

IPv4 地址共 32 bit，分为 A，B，C，D，E 类。

* A 类，网络号以 0 开头，地址范围 `1.0.0.0-127.255.255.255`，网络号 8 位，主机号 24 位。子网掩码`255.0.0.0`
* B 类，网络号以 10 开头，地址范围 `128.0.0.0-255.255.255`，网络号 16 位，主机号 16 位。子网掩码`255.255.0.0`
* C 类，网络号以 110 开头，地址范围 `192.0.0.0-223.255.255.255`，网络号 24 位，主机号 8 位。子网掩码`255.255.255.0`
* D 类，前四位固定为 1110，后面为多播地址，所以 D 类地址为多播地址。
* E 类，前五位固定为 11110，后面保留为今后使用。

IPv6 地址共128 bit，首部固定部分为 40 字节。

子网掩码是一个 32 位地址，与 IP 地址结合使用的一种技术，两个作用：

1. 屏蔽 IP 地址的一部分用于区别网络标识和主机标识，并说明该 IP 地址是在局域网上，还是在远程网上。
2. 用于将一个大的 IP 网络划分为若干个小的子网。

子网掩码的位数决定于可能的子网数目和每个子网的主机数目。

### 六、 在浏览器中输入网址后执行会发生什么

* 查找域名对应的 IP 地址。依次查找浏览器缓存，系统缓存，路由器缓存（本地hosts文件）， ISP DNS 缓存（本地域名服务器），根域名服务器。
* 建立TCP连接（三次握手）
* 浏览器向 IP 对应的 web 服务器发送一个 HTTP 请求，cookies会跟着请求发送给服务器。

  1. 应用层：客户端发送 HTTP 请求报文（HTTP 协议）
  2. 传输层：切分长数据，并确保可靠性（ TCP 协议）
  3. 网络层： 进行路由（ IP 协议，路由选择用 OSPF 协议）
  4. 数据链路层：传输数据（将 IP 地址转为 MAC 地址，使用 ARP 协议）
  5. 物理层：物理传输 bit
* 服务器响应请求，发回网页内容。
* 浏览器解析网页内容（HTML）。

### 七、简单解释一下 ARP 协议的工作过程

ARP，地址解析协议，根据 IP 地址获取物理地址的一个TCP/IP协议。处理**同一个局域网**上，主机和和路由器的 IP 地址与MAC 地址的映射关系。

* 每个主机上都设有一个 **ARP高速缓存**，保存本局域网中各主机和和路由器的 IP 地址与MAC 地址的映射关系。

* 主机 A 向本局域网的主机 B 发送 IP 数据报时，首先检查自己的 ARP 列表中是否有 B 的 MAC 地址，如果有，则直接发送数据；若否，则向本网段的所有主机发送 ARP 数据包，包括：A 的 IP 地址，A 的 MAC 地址，B 的 IP 地址。
* 本网络的所有主机收到该 ARP 数据包时，首先检查自己的 IP 是不是目的IP，若不是则忽略该数据包；若是则将 A 的 IP 地址和 MAC 地址写入自己的 ARP 缓存中。
* 主机 B 将包含其 MAC 地址的 回复消息直接发送回主机 A。
* 主机 A 收到 ARP 响应包后，将 B 的 IP 地址和 MAC 地址写入自己的 ARP 列表，并发送数据。如果一直没收到相应包，表示 ARP 查询失败。

### 八、说一下 OSI 七层模型

OSI/RM，开放系统互联基本参考模型。一个试图让各种计算机在世界范围内互联成网的标准框架。因为制定周期过长使得应用设备无法及时到达时长、实现起来过于复杂且运行效率过低，层次划分不太合理，层级之间有些功能多次出现等原因，只获得了一些理论研究的成果，在市场化失败。市场化通常采用 TCP/IP 四层模型。

1. 物理层，使用传输介质为数据链路层提供物理连接，实现比特流的透明传输。

2. 数据链路层，负责建立和管理节点间的链路。主要功能是通过各种*控制协议*，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。将网络层交下来的**IP数据报**组装成**帧**。**解决同一网络内节点之间的通信。**这两层可以合称网络接口层。

3. 网络层，OSI 参考模型中**最复杂一层**，也是通信子网的最高一层。**解决不同子网间的通信**。主要任务是通过*路由选择算法*，为报文或分组通过通信子网选择最适当的路径。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成**分组**或**包**进行传送，在 TCP/IP 体系中，分组也叫作 **IP 数据报**。

  * 该层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。
  * 使用 IP 协议，可以将异构的物理网络连接起来，使得在网络层看起来好像是个统一的网络。

      主要解决的问题如下：

    ​	  **1.** 寻址，数据链路层用的物理地址仅解决网络的内部寻址，在不同子网间通信时，每一个子网中的设备都会被分配唯一的地址。各子网使用的物理技术不同，因此该地址应当是逻辑地址（如 IP 地址）。

    ​	  **2.** 交换，规定不同的信息交换方式，常见的交换技术有线路交换技术和存储转发技术，后者包括报文交换技术和分组交换技术。

    ​	  **3.** 路由算法，源节点和目的节点之间存在多条路径时，本层通过路由算法为数据分组选择最佳路径。

    ​	  **4.** 连接服务：防止阻塞，并进行差错检测。

4. 运输层，OSI 下三层主要任务是**数据通信**，上三层主要任务是**数据处理**。因此本层负责向两台主机中的进程提供通用的数据传输服务，起到承上启下的作用。主要任务是向用户提供可靠的端到端的差错和流量控制，保证报文的正确运输。向高层屏蔽下层数据通讯的细节，向用户透明的传送报文。

   主要使用两种协议：

   * 传输控制协议 TCP——提供面向连接的，可靠的数据传输服务，数据传输单位是**报文段**。
   * 用户数据报协议 UDP——提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），数据传输单位是**用户数据报**。

5. 会话层，表示层和应用层。应用层的任务是通过应用进程之间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。如 域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议，等等。应用层交互的数据单元称为 报文。

实际学习计网原理时采取折中的办法，使用五层协议，物理层、数据链路层、网络层、运输层和应用层。

### 九、说一下 TCP/IP 四层模型

网络接口层（对应物理层+数据链路层），网络层 IP ，运输层（ TCP 或 UDP），应用层（各种应用层协议如 TELNET ,  FTP ,  SMTP 等） 。TCP/IP 体系结构不严格遵循 OSI 分层，应用层可能会直接使用网络层或网络接口层。

* 网络接口层在 TCP/IP 参考模型中没有真正描述实现，提供给网络层一个传输接口，以便在上面传递 IP 分组。
* 网络层，解决不同子网之间的通信；通过路由选择算法为 IP 数据报选择最合适的路径；拥塞控制。
* 运输层，TCP协议或UDP 协议。
* 应用层，面向不同的网络应用有不同的协议。

### 十、 HTTP 协议包括哪些请求

* GET，对服务器资源的简单请求
* POST，用于发送包含用户提交数据的请求。
* HEAD，类似于 GET，返回的响应中无具体内容，用于获取报头
* PUT，自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不用
* PATCH，对资源部分修改（put 则是完全替代）
* DELETE，发送一个删除指定文档的请求，与PUT 相反，同样不带验证机制
* TRACE，发送一个请求副本，以跟踪其处理进程。
* OPTIONS，返回所有可用的方法，检查服务器支持哪些方法
* CONNECT，要求在与代理服务器通信时建立隧道。使用 SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。

### 十一、简述 HTTP 中 GET 和POST 的区别

原理上：

* GET 用于信息获取，是安全和幂等、可缓存的。**URL只支持 ASCII 码**，因此 GET 的参数中如果存在中文等字符就需要先进行编码。POST 参数支持标准字符集。
* POST 用于传输实体主体，可能修改服务器上资源的请求。多数情况不可缓存。

表面上：

* GET 请求的参数以查询字符串的形式会附在 URL 后面，POST 的数据放在 HTTP 包内。
* 不能因为POSTT参数存放在实体主体中就认为它的安全性更高，照样可以通过一些抓包工具（Fiddler）查看。

安全的 HTTP 方法：不会改变服务器状态，即只是可读的，有 GET/HEAD/OPTIONS；不安全的方法有POST/PUT/DELETE。

幂等的方法：同样的请求被执行一次与连续执行多次的效果一样，服务器状态也是一样的。换句话说，幂等方法不应该具有副作用。所有的安全方法都是幂等的。GET/HEAD/PUT/DELETE等方法都是幂等的。POST 方法不是。

可缓存：如果要对响应进行缓存，需要满足以下条件：

- 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定不进行缓存。

XMLHttpRequest：一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

* 在使用 XMLHTTPRequest 的 POST 方法时，浏览器先发送 Header 再发送 Data。但不是所有的浏览器都会这么做，例如火狐就不会。
* 而 GET 方法的 Header 和 Data 会一起发送。

### 十二、简述TCP 流量控制和拥塞控制

#### 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接受。

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率，将窗口字段设置为0，则发送方不能发送数据。

#### 拥塞控制

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因而当发生拥塞时，应当控制发送方的速率。和流量控制相似但出发点不同，流量控制是为了**让接收方能来得及接受**，拥塞控制是为了**降低整个网络的拥塞程度**。

发送方维护一个叫做拥塞窗口（cwnd）的状态变量。（实际决定发送发能发送多少数据的是发送方窗口）

TCP 通过四个算法进行拥塞控制，慢开始，拥塞避免，快重传，快恢复。两两搭配。

* 慢开始和拥塞避免：

  拥塞窗口 =1，发送方只能发送一个报文段，收到确认时，cwnd 加倍，因此之后能够发送的报文段数量为2,4,8...

  慢开始每个轮次都将 cwnd 加倍，发送方速度增长很快，网络拥塞可能性更高。设置慢开始门限ssthresh，当cwnd>ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 增加 1 。

  如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始，即 cwnd = 1。

* 快重传与快恢复：

  在接收方，要求每次收到报文段都直接对最后一个已收到的有序报文段进行确认。

  在发送方，连续收到三个重复确认，则知道下一个报文段丢失，此时执行**快重传**，立即重传下一个报文段。

  在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行**快恢复**，ssthresh = ssthresh / 2，cwnd = ssthresh，并开始执行拥塞避免（cwnd 一次加一）。

### 十三、HTTP和HTTPS的特性与区别



## 查漏补缺篇--各层攻坚

### 概述
----------

#### 1. ISP，互联网服务提供商
从互联网管理机构获得 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定费用即可接入互联网。

#### 2. 主机之间的通信方式

   客户-服务器，一个请求服务一个提供服务；对等（P2P）：不区分客户和服务器。

#### 3. 电路交换和分组交换

   * 电路交换用于电话通信系统，专用物理链路，线路利用率低
   * 分组交换每个分组都有首部和尾部，包含源地址和目的地址等控制信息，同一条传输线路可同时传输多个分组互不影响。使用存储转发过程。

#### 4. 总时延
= （路由器中）排队时延 + 处理时延 + 传输时延 + （电磁波在信道中）传播时延

#### 5. 五层协议

#### 6. OSI

#### 7. TCP/IP 体系结构

#### 8. 数据在各层之间的传递过程

   向下的过程中，需要添加下层协议所需首部或尾部，而在向上过程中不断拆开首部和尾部。

   路由器只有下三层，路由器处于网络核心，不需为进程或应用程序提供服务，因此不需要传输层和应用层。

### 物理层
-----

#### 1. 通信方式

   根据信息在传输线上的传送方向，分为以下三种通信方式：

   * 单工通信：单向传输
   * 半双工通信：双向交替传输
   * 全双工通信，双向同时传输

#### 2. 带通调制

   模拟信号是连续的信号，数字信号是离散的信号。带通调制是把数字信号转换为模拟信号。

### 链路层
-----------

#### 1. 封装成帧
将网络层传下来的分组（IP数据报）添加首部和尾部，用于标记帧的开始和结束。

#### 2. 透明传输

   如果帧的数据部分含有和首部尾部相同的内容，将数据部分的相同内容前加转义字符；如果数据部分出现转义字符，在转义字符前加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。即，一个实际的东西，看起来好像不存在一样。

#### 3. 差错检测
数据链路层广泛使用循环冗余检验（CRC）来检查比特差错。

#### 4. 信道分类

   * 广播信道，一对多通信，所有节点都在同一个广播信道上发送数据，需要控制方法协调，避免碰撞。两种方法，信道复用技术和 CSMA/CD 协议。
   * 点对点信道，一对一通信，不会发生碰撞，比较简单，使用 PPP 协议控制。

#### 5. 信道复用技术

   1. 频分复用，相同的主机在相同的时间占用不同的频率带宽资源。
   2. 时分复用，所有的主机在不同的时间占用相同的频率带宽资源。1 和 2 在通信过程中主机一直占用一部分信道资源不给其他用户，因此信道利用率都不高。
   3. 统计时分复用，不固定每个用户在时分复用帧中的位置，只要有数据集中起来组成统计时分复用帧然后发送。
   4. 波分复用，光的频分复用，由于光的频率很高，习惯上用波长而不是频率来表示所使用的光载波。
   5. 码分复用，为每个用户分配 m bit 的码片，所有的码片正交，任意两个码片正交除以 m 等于 0。码分复用需要发送的数据量为原来的 m 倍。

#### 6. CSMA/CD 协议

   表示载波监听多点接入 / 碰撞检测。

   * 多点接入，说明这是总线型网络，许多主机以多点的方式连接到总线上。

   * 载波监听，每个主机必须不停地监听信道。在发送前，如故宫监听到信道正在使用，就必须等待。

   * 碰撞检测，在发送中，如果坚挺到信道已有其他主机正在发送数据，就表示发生了碰撞。（虽然发送数据之前监听到信道空闲，但是电磁波有传播时延，因此可能有碰撞）。

     以端到端的传播时延为单位，最先发送的站点最多经过两个传播时延就可以知道是否发生了碰撞，两个传播时延为争用期。碰撞发生时，站点要停止发送，等待一段时间再发送。这个时间采用 **截断二进制指数退避算法** 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。

#### 7. PPP 协议

   互联网用户连接到某个 ISP 后才能接入到互联网，PPP 协议是用户计算机 与 ISP 进行通信时所使用的数据链路层协议。

   PPP 帧格式： F | A | C | 协议 | IP 数据报 | FCS | F

   * F 字段为帧的定界符
   * A C 字段暂时无意义
   * FCS 字段是使用 CRC 的检验序列
   * 信息部分的长度不超过 1500

#### 8. MAC 地址

   链路层地址，长度为 6 字节，48位，用以唯一标识网络适配器（网卡）。一台主机有几个网络适配器就有几个 MAC 地址，如笔记本电脑通常存在无线网络适配器和有线网络适配器，因此有两个 MAC 地址。

#### 9. 局域网

   一种典型的广播信道，主要特点为网络为一个单位所拥有，且地理范围和站点数目均有限。

   主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。

#### 10. 以太网

​	一种星型拓扑结构局域网，使用**交换机**替代了集线器，不会发生碰撞，能根据 MAC 地址进行存储转发。

​	早期使用集线器进行连接，集线器是一种**物理层设备**， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。

​	以太网帧格式：目的地址 | 源地址 | 类型 | IP 数据报 | FCS    

* 类型：标记上层使用的协议
* 数据：长度在 46-1500 直接，如果太小则需要填充
* FCS：帧检验序列，使用的是 CRC 检验方法

#### 11.交换机

交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。
    
因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。
    
工作原理类似 **ARP 协议**，交换机上 4 个接口，分别连接 4 台主机。A 向 B 发送数据帧时，交换机将 A 到接口 1 的映射写入交换表。然后查表找是否有 B ，此时没有 B 的表项，那么 A 发送广播帧，C D 丢弃该帧， B 回应该帧向 A 发送数据包时，交换机查找交换表得到 A 的映射接口为1 ，就发送数据帧到接口 1 ，同时交换机添加主机 B 到接口 2 的映射。 

#### 12. 虚拟局域网

虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。

使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。

### 网络层
-------------

#### 1. IP 数据报格式

   首部 + 数据部分，首部由固定部分（20 字节）和可变部分组成。

   * 版本，有 4 和 6 两个值（ IPv4 和 IPv6）
   * 首部长度，占 4 位，最大值为 15。值为 1 表示 1 个 32 位字的长度，即 4 字节。最小为5（固定部分为 20 字节）。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。
   * 区分服务，用来获得更好的服务，一般情况下不使用。
   * 总长度，包括首部长度和数据部分长度。
   * 生存时间，TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。
   * 协议，支持携带的数据应当上交为哪个协议进行处理，例如 ICMP，TCP，UDP等。
   * 首部检验和，因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。
   * 标识，在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。
   * 片偏移，和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

#### 2. IP 地址编址方式

   历经三个历史阶段，分类、子网划分、无分类。

   * 分类，由网络号和主机号组成。A,B,C类。`IP 地址 ::= {< 网络号 >, < 主机号 >}`

   * 子网划分，在主机号中拿一部分作为子网号，划分三级 IP 地址。`IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}`，外部网络看不到子网的存在。

   * 无分类，无分类编址 CIDR 消除了传统分类和子网划分的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化，`IP 地址 ::= {< 网络前缀号 >, < 主机号 >}`。一个 CIDR  地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。

     在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。

     CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

#### 3. 地址解析协议 ARP

#### 4. 网络控制报文协议 ICMP

    类型 | 代码 | 检验和 | 数据部分

   ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它**封装在 IP 数据报中**，但是不属于高层协议。

   ICMP 报文分为差错报告报文（类型3：终点不可达；类型11：时间超过；类型12：参数问题；类型5：改变路由）和询问报文（类型8或0：回送请求或回答；类型13或14：时间戳请求或回答）。

   1. Ping，ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。
   2. Traceroute，ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。
      - 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
      - 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
      - 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
      - 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

#### 5. 虚拟专用网 VPN

   * 私有地址，见[基础篇一][]。一个机构内的计算机可以使用仅在本机构内的有效 IP 地址。VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其他主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。
   * 场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。

#### 6. 网络地址转换 NAT

   专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球IP。

   在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。

   `源 IP 地址：TCP 源端口`

#### 7. 路由器的结构

   从功能上，路由选择和分组转发。分组转发结构由三部分组成：交换结构、一组输入端口和一组输出端口。

#### 8. 路由器分组转发流程

* 每个路由器都有一个路由表，包括目的网络和下一跳地址。
* 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
* 若 N 就是与此路由器直接相连的某个网络地址，则直接交付；
* 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中指明的下一跳路由器；
* 如果路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；
* 若路由表中有一个默认路由，则把数据报传送给它；
* 报告转发分组出错。

#### 9. 路由选择协议 RIP、OSPF、BGP

路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应的进行调整。互联网可以划分为许多较小的自治系统 AS，路由选择协议主要分为两大类：

* 自治系统内部的路由选择： RIP 和 OSPF
* 自治系统间的路由选择：BGP

1. **内部网关协议 RIP**

   一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。

   RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

   实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。

2. **内部网关协议 OSPF**

   开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。

   开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。

   OSPF 具有以下特点：

   - 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。
   - 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
   - 只有当链路状态发生变化时，路由器才会发送信息。

   所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。

3. **外部网关协议 BGP（边界网关协议）**

   AS 之间的路由选择很困难，主要是由于：

   - 互联网规模很大；
   - 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
   - AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

   BGP 只能寻找一条比较好的路由，而不是最佳路由。

   每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。

### 传输层

----

#### 1. UDP 和 TCP 的特点

无连接/有连接，最大可能/可靠交付，无/有拥塞控制和流量控制，面向报文/字节流，半双工/全双工，一对一对多多对一对多/点对点。

#### 2. UDP 首部格式

 8 个字节，包括源端口，目的端口，长度，检验和。12 字节的伪首部是为了计算检验和临时添加的。

#### 3. TCP 首部格式

固定 20 字节 + 可变部分 + 填充。

* 序号，给字节流进行编号
* 确认号，期望收到的下一个报文段的序号。
* 数据偏移，指数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
* 确认 ACK，当 ACK = 1 时确认号字段有效，否则无效。连接建立后所有传送的报文段都必须把 ACK 置 1。
* 同步 SYN，在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
* 终止 FIN，用来释放一个连接，当 FIN = 1，表示该报文段的发送方的数据已发送完毕，并要求释放连接。
* 窗口，窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

#### 4. TCP 的三次握手

#### 5. TCP 的四次挥手

#### 6. TCP 可靠传输

​	超时重传：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

#### 7. TCP 滑动窗口

#### 8. TCP 流量控制

#### 9. TCP 拥塞控制

#### 10. 套接字

`主机 IP 地址：端口号`

应用层通过传输层进行数据通信时，为了区分不同的应用进程和连接，操作系统为应用程序和 TCP/IP 协议交互提供了套接字接口，区分不同应用程序进程之间的网络通信和连接。Socket，原意“插座”。主要有3个参数：通信的目的IP地址、使用的传输 层协议(TCP或UDP)和使用的端口号。

一个程序将一段信息写入 Socket，该 Socket 将这段信息发送给另一个 Socket中，使这段信息能传送到其他程序。

要通过互联网进行通信，至少需要一对套接字。



### 应用层

--------

#### 1. 域名系统 DNS

DNS 是一个分布式数据库，提供了主机名和 IP 地址之间互相转换的服务。这里的分布式数据库指每个站点只保留它自己的那部分数据。

域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。

DNS 可以使用 UDP 或者 TCP 进行传输，**使用的端口号都为 53**。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：

- 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

#### 2. 文件传送协议 FTP

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：

- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
- 数据连接：用来传送一个文件数据。

根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：

- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。

- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

  主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是**被动模式会导致服务器端的安全性减弱，**因为开放了过多的端口号。

#### 3. 动态主机配置协议 DHCP

DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。

DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。

* DHCP客户端发送IP地址租用申请，放入 UDP 报文中，广播方式发出。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。

* 网络中的DHCP服务器回应一个IP地址租用提供，
* 客户端选择第一个DHCP返回的包的DHCP服务器。广播发送DHCPREQUEST消息，通知其他的DHCP服务器放弃，同时通知选中的DHCP服务器，包含申请IP地址。

* 最后DHCP服务器会送DHCPACK消息，返回客户端可以使用这个IP地址。
  

#### 4. 远程登录协议 TelNet

TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。**常用端口号 23。**

TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。

#### 5. 电子邮件协议SMTP/POP3/IMAP

一个电子邮件系统由三部分组成：用户代理，邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。

* SMTP，简单邮件传送协议，只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 不改动或替代 SMTP，只是增加邮件主体的结构，定义了非 ASCII 码的编码规则。
* POP3，邮件读取协议，只要用户从服务器上读了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。
* IMAP，网络报文存取协议，客户端和服务器上的邮件保持同步，如果不手动删除，那么服务器上的邮件也不会被删除。

#### 6. 常用端口

| 应用             | 应用层协议 | 端口号  | 传输层协议 | 备注                        |
| ---------------- | ---------- | ------- | ---------- | --------------------------- |
| 域名解析         | DNS        | 53      | UDP/TCP    | 长度超过 512 字节时使用 TCP |
| 动态主机配置协议 | DHCP       | 67/68   | UDP        |                             |
| 简单网络管理协议 | SNMP       | 161/162 | UDP        |                             |
| 文件传送协议     | FTP        | 20/21   | TCP        | 控制连接 21，数据连接 20    |
| 远程终端协议     | TELNET     | 23      | TCP        |                             |
| 超文本传送协议   | HTTP       | 80      | TCP        |                             |
| 简单邮件传送协议 | SMTP       | 25      | TCP        |                             |
| 邮件读取协议     | POP3       | 110     | TCP        |                             |
| 网际报文存取协议 | IMAP       | 143     | TCP        |                             |

------------------

#### 7. Web 页面请求过程(详细到底层版)

##### 1. DHCP 配置主机信息

- **假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。**
- 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。
- 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。
- 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。
- 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。
- 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。
- 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

##### 2. ARP 解析 MAC 地址

- **主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。**
- 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。
- 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。
- 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。
- DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。
- 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。
- 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。

##### 3. DNS 解析域名

- 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。
- 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。
- 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。
- 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。
- 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

##### 4. HTTP 请求页面

- **有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。**
- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。
- HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。
- 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。
- HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。
- **浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。**



## 冲冲冲——HTTP

### 1. HTTP 中 GET 和 POST 的区别（安全、幂等、可缓存、XMLHttpRequest，基础篇题十一）

### 2. HTTP 具体应用（3-13）

-----------

* 连接管理：长连接与短连接；流水线
* Cookie（和Session对比）

### 3. 长连接与短连接

当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。

- 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 `Connection : Keep-Alive`。

### 4. 流水线

默认情况下，HTTP 请求顺序发出，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能要等待很长时间。

流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

### 5. Cookie（session 对比，session维护用户登录态）

HTTP 是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来**保存状态信息**。

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务器两个请求来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。

1. **用途**

   * 会话状态管理（用户登录状态，购物车、游戏分数等需要记录的信息）
   * 个性化设置（如用户自定义设置、主题等）
   * 浏览器行为跟踪（如跟踪分析用户行为等）

2. **创建过程**

   服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。

   ```
   HTTP/1.0 200 OK
   Content-type: text/html
   Set-Cookie: yummy_cookie=choco
   Set-Cookie: tasty_cookie=strawberry
   
   [page content]
   ```

   客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。

   ```
   GET /sample_page.html HTTP/1.1
   Host: www.example.org
   Cookie: yummy_cookie=choco; tasty_cookie=strawberry
   ```

3. **分类**

   * 会话期 Cookie：浏览器关闭后它会被自动删除，也就是说它仅在会话期间有效。
   * 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后成为了持久性的 Cookie。

   ```
   Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
   ```

4. **作用域**

   Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，**默认为当前文档的主机（不包含子域名）**。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。

   Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：

   - /docs
   - /docs/Web/
   - /docs/Web/HTTP

5. **JavaScript**

   浏览器通过`document.cookie`属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。

   ```
   document.cookie = "yummy_cookie=choco";
   document.cookie = "tasty_cookie=strawberry";
   console.log(document.cookie);
   ```

6. **HttpOnly**

   标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 `document.cookie` API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。

   ```
   Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
   ```

7. **Secure**

   标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。**但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性**，Secure 标记也无法提供确实的安全保障。

8. **Session**

   用户信息可以通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。

   Session 可以存储在服务器的文件、数据库或者内存中。也可以存在`Redis`这种内存型的数据库中，效率会更高。

   使用 Session 维护用户登录状态的过程如下：

   - 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
   - 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
   - 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
   - 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

   应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。

9. **浏览器禁用 Cookie**

   此时无法使用 Cookie 来保存用户信息，只能使用 Session。

   不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。

10. **Cookie 与 Session 选择**

    - Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此**在考虑数据复杂性时首选 Session**；
    - Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；
    - 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此**不建议将所有的用户信息都存储到 Session 中**。

### 6. 缓存

#### - 优点

* 缓解服务器压力
* 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上可能比源服务器更近，例如浏览器缓存。

#### - 实现方法

   * 让代理服务器进行缓存
   * 让客户端浏览器进行缓存

#### - Cache-Control 字段

   HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。

   ```
   Cache-Control: no-store//禁止进行缓存
   Cache-Control: no-cache//强制确认缓存，缓存服务器需要先向源服务器验证缓存资源的有效性
   Cache-Control: private//规定了将资源作为私有缓存，只能被单独用户使用；一般存储在用户浏览器中
   Cache-Control: public//将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中
   ```

   缓存过期机制

   ```
   Cache-Control: max-age=31536000
   Expires: Wed, 04 Jul 2012 08:26:05 GMT
   ```

   * max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

     max-age 指令出现在响应报文，表示缓存资源在缓存服务器中存的时间。

     在 HTTP/1.1 中，会优先处理 max-age 指令；在 HTTP/1.0 中，max-age 指令会被忽略掉。

   * Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。

#### - 缓存验证

   需要先了解 `ETag` 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。

   ```
   ETag: "82e22293907ce725faf67773957acd12"
   ```

   可以将缓存资源的 ETag 值放入 `If-None-Match` 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。

   ```
   If-None-Match: "82e22293907ce725faf67773957acd12"
   ```

   Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。

   如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。

   ```
   Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
   If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
   ```


### 7. 内容协商（谁迁就谁）

根据内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。

#### - 类型

* 服务端驱动型

  客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。

  它存在以下问题：

  - 服务器很难知道客户端浏览器的全部信息；
  - 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；
  - 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。

* 代理驱动型

  服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。

#### - Vary

```
Vary: Accept-Language
```

在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。

### 8. 内容编码（服务器迁就客户端）

内容编码将实体主体进行压缩，从而减少传输的数据量。

常用的内容编码有：gzip、compress、deflate、identity。

浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。

### 9. 范围请求（有了就不用再发了）

如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。

* Range
* Accept-Ranges
* 响应状态码

### 10. 分块传输编码

Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。

### 11. 多部分对象集合

一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，**每个部分都可以有首部字段。**

### 12. 虚拟主机

HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。

### 13. 通信数据转发

- 代理

  代理服务器接受客户端的请求，并且转发给其他服务器。

  使用代理的主要目的：

  * 缓存
  * 负载均衡
  * 网络访问控制
  * 访问日志记录

  代理分为正向代理和反向代理两种：

  * 用户察觉的到正向代理的存在
  * 反向代理一般位于内部网络中，用户察觉不到。

- 网关

  与代理服务器不同，网关服务器会将 HTTP 转化为其他协议进行通信，从而请求其他非 HTTP 服务器的服务。

- 隧道

  使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。

-------------

### 14. HTTPS

HTTP 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

#### 加密

* 对称密钥加密（加密解密使用同一密钥）

  运算速度快；无法安全的将密钥传输给通信方。

* 非对称密钥加密（公开密钥加密，即可加密，也可签名）

  公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

  非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

  - 优点：可以更安全地将公开密钥传输给通信发送方；
  - 缺点：运算速度慢。

* **HTTPS 采取的加密方式**

  上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：

  - 浏览器发送建立连接请求
  - 服务器将公钥发送给浏览器
  - 浏览器将 Session Key以公钥加密，发送给服务器
  - 服务器用私钥解密，会的对称密钥
  - 之后通信使用对称密钥加密

#### 认证

通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

#### 完整性保护

SSL 提供报文摘要功能来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

#### HTTPS 的缺点

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。

### 15. HTTP/1.0 和 HTTP/2.0

--------

#####  HTTP/1.x 实现简单是以牺牲性能为代价的

- 客户端需要使用多个连接才能实现并发和缩短延迟；
- 不会压缩请求和响应首部，从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

##### HTTP/1.1 新特性

- 默认是长连接
- 支持流水线
- 支持同时打开多个 TCP 连接
- 支持虚拟主机
- 新增状态码 100
- 支持分块传输编码
- 新增缓存处理指令 max-age

##### HTTP/2.0 的改进

* HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。
* 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。
* 服务端一次性推送：客户端请求一个资源时，将相关资源一起发送给客户端。
* 首部压缩：HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。
* HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。