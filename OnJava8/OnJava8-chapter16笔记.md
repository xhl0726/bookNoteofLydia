[TOC]

## 第十六章 代码校验

> 你永远不能保证你的代码是正确的，你只能证明它是错的。
>
> ！！！测试用例不是用来证明你是对的，而是用来证明你没错。

### 测试

--------

#### 如果没有测试过，它就是不能工作的。

  Java 是一个静态类型的语言。静态类型检查只说明编译器接受你代码中的**语法和基本类型规则**，并不意味着你的代码达到程序的目标。

#### 单元测试

  “单元”是指测试一小部分代码。这个过程是将集成测试构建到你创建的所有代码中，并在每次构建系统时运行这些测试。这样构建过程可以同时检查到语法和**语义**的错误。

  Java 的安全性保障有垃圾回收、改良的类型检测等。单元测试集成到构建过程，帮助扩大了这个安全保障，因此

  1. 有了更快的开发效率。
  2. 可以更容易重构代码。

  构建系统 Gradle：安装 JDK 后`gradlew compile Java`，编译所有代码。

#### JUnit-最流行的单元测试框架

  JUnit 最初版本不能使用 Java 的反射工具，而今通过反射和注解得到了极大地改进。

**使用方法：**

* 新建测试类，使用`@Test`注解标记表示测试的每个方法。JUnit 将这些方法标识为单独测试，并**一次设置和运行一个测试**，避免测试之间的副作用。标准做法是将测试放在它们自己的子目录中。测试还必须放在包中。

* 注解：

  `@BeforeAll` 在任何其他测试操作之前运行一次的方法。必须是 static 的。

  `@AfterAll` 所有其他测试操作之后只运行一次的方法。必须是 static 的。

  `@BeforeEach` 通常用于创建和初始化公共对象的方法，并在每次测试前运行。可以把所有的初始化放在测试类的构造函数中，但是 @BeforeEach 更加清晰。

  `@AfterEach` 如果修改了需要恢复的静态文件，打开文件需要关闭，打开数据库或者网络连接等，在每次测试后执行清理。

* JUnit 断言方法（以“assert”开头）

  断言失败则显示导致失败的表达式和值；断言语句有重载版本，包含一个字符串。

  断言语句不是必须的。不抛出异常，则认为测试成功。

* 使用**Gradle**控制测试：使用命令`gradlew validating:test`运行本章测试，Gradle 不会运行已经运行过的测试，如果没有测试结果，首先`gradlew validating:clean`。

#### 测试覆盖率的幻觉

  测试覆盖率/代码覆盖率，度量代码的测试百分比。100% 的测试覆盖并不意味着是**对测试有效性**的良好测量。覆盖工具的最佳用途是发现代码库中未测试的部分，但是不要依赖覆盖率来腿儿测试质量的任何信息。



### 前置条件

-----

前置条件的概念来自于契约式设计（DbC），利用断言机制实现。我们从 Java 的断言机制开始来介绍 DBC，最后使用谷歌的 Guava 库作为前置条件。

#### 断言（Assertions）

断言通过验证在程序执行期间满足某些条件，从而增加了程序的健壮性。

如果在方法内部，则可以使用断言检查参数的有效性。

这些是确保程序正确的重要测试，但是它们不能在编译时被检查，且不属于单元测试的范围。

#### Java 断言语法

Java 断言语句易于编写，有两种形式：

* `assert boolean-expression;`
* `assert boolean-expression: information-expression;`

断言中的表达式产生 false 则抛出 **AssertionError** 异常（ **Throwable** 的派生类，因此不需要异常说明）。`information-expression`可以产生任何类型的对象，因此通常构造一个包含对象值的更复杂的字符串，它包含一个失败的断言。

运行程序时需要**显式启动断言**，断言语句才会被执行。方法为

1. 使用 **-ea** 标志，如`java -ea Assert1`（Assert1 为测试类名）。虽然简单，但是交付独立产品时可能必须设置一个执行脚本让用户能够启动程序，配置其他启动参数。

2.  可基于类名或包名打开或关闭断言，即可以对整个包启动或禁用断言。此特性对使用断言的大型项目来说很有用，但是日志记录或者调试，可能更有用。

3. 可通过编程的方式通过链接到类加载器对象来控制断言。类加载器中有几种方法允许动态启用和禁用断言，如在 main() 中执行：

   ```java
   ClassLoader.getSystemClassLoader().
           setDefaultAssertionStatus(true);//该句为之后加载的所有类设置断言状态
   ```

   在程序运行时启动断言可以使用下面的 static 语句块，该语句位于系统的主类中：

   ```java
   static {
       boolean assertionsEnabled = false;
       assert assertionsEnabled = true;
       if(!assertionsEnabled)
           throw new RuntimeException("Assertions disabled");
   }
   ```

#### Guava 断言

Guava 团队添加一个始终启用的用来替换断言的 **Verify** 类，他们建议静态导入 **Verify** 方法：

* `Verify()` 判断是否为 boolean
* `VerifyNotNull()` 判断是否为 null ，该方法内置的错误消息通常就足够了。

#### 使用断言进行契约式设计（DbC）

契约式设计：通过确保对象遵循某些规则来帮助创建健壮的程序。

这些规则是由正在解决的问题的性质决定的，这超出了编译器可以验证的范围。

1. 应该明确指定行为，就好像它是一个契约一样。

2. 通过实现某些运行时检查来保证这种行为，这些检查称为前置条件、后置条件和不变项。

#### 检查指令

检查指令说明你确信代码中的某个特定属性此时已经得到满足。其思想是**在代码中表达非明显性的结论**，而不仅仅是为了验证测试，也同样为了将来能够满足阅读者而有一个文档。

#### 前置条件/后置条件

前置条件确保客户端（调用此方法的代码）履行部分契约。是确保检查的一个好做法。

后置条件测试你在方法中所做的操作的结果，放在方法调用的末尾。任何时候你可以描述方法结果上的约束时，最好将这些约束在代码中表示为后置条件。

#### 不变性

不变性保证了在方法调用之间维护的对象的状态。但是它并不会阻止方法在执行过程中暂时偏离这些保证，只是说对象的状态信息应该总是遵守状态规则：

1. 在进入该方法时。
2. 离开方法之前。

一个有效的不变性被定义为一个方法，在构造之后以及每个方法的开始和结束时调用，方式如下：

`assert invariant()` 

如果禁用断言，则不会产生开销。

#### 放松 DbC 检查或非严格的 DbC 检查

放松检查的禁用顺序：

1. 每个方法一开始时的不变性检查，因为末尾的不变性检查能保证一开始的对象处于有效状态。
2. 可禁用后置条件检查，当你进行合理的单元测试以验证方法是否返回了适当的值时。
3. 如果确信方法主体没有将对象改成无效状态，可禁用方法末尾的不变性检查。可通过**白盒单元测试**（通过访问私有字段的单元测试来验证对象状态）来验证这一点。
4. 禁用前置条件检查，除非万不得已的情况下。因为尽管你知道且可控制自己的代码，但是你（一般）无法控制客户端可能会传递给方法的参数。

不应该直接删除检查的代码，只需要禁用检查，即添加注释。

#### DbC + 单元测试

对 DbC 方法调用前置`assert`，如果出于性能考虑禁用断言，则根本不存在方法调用。

有效性检查（不变性）如果每次都调用，则花销巨大。使用`invariant()`清晰表明帮助完成调试，并移到单元测试代码中，是有帮助的。

将 Dbc 和单元测试结合起来，你不仅可以同时使用这两种方法，还可以有一个迁移路径—你可以将一些 DbC 测试迁移到单元测试中，而不是简单地禁用它们，这样你仍然有一定程度的测试。

#### 使用 Guava 前置条件

非严格的 DbC 中，前置条件是你想要保留的一部分，因为它可以检查参数的有效性。Java 在默认情况下禁用断言，所以可以使用另外一个始终验证方法参数的库。

谷歌的 Guava 库包含了一组前置条件测试，易于使用，命名优秀。建议**静态导入前置条件**。

每个前置条件都有三种不同的重载形式：一个什么都没有，一个带有简单字符串消息，以及带有一个字符串和替换值。为了提高效率，只允许 **%s** (字符串类型)替换标记。

所有的 Guava 前置条件对于基本类型和对象都有必要的重载。

### 测试驱动开发（TDD）

----

如果在设计和编写代码时考虑到测试，不仅可以写出测试性更好的代码，而且可以得到更好的代码设计。——“面向测试的开发”。

JUnit5 中的复杂功能：**动态测试生成。**使所编写的代码在运行时生成测试，而不需要对每个测试显式编码。JUnit5 提供了几种动态生成测试的方法， **DynamicTest.stream() **方法采用了：

- 对象集合上的迭代器 (versions) ，这个迭代器在不同组的测试中是不同的。 迭代器生成的对象可以是任何类型，但是只能有一种对象生成，因此对于存在多个不同的对象类型时，必须人为地将它们打包成单个类型。
- **Function**，它从迭代器获取对象并生成描述测试的 **String** 。
- **Consumer**，它从迭代器获取对象并包含基于该对象的测试代码。

你可以通过这种方式进行开发：一开始在测试中建立你期望程序应有的所有特性，然后你就能在实现中一步步添加功能，直到所有测试通过。 完成后，你还可以在将来通过这些测试来得知（或让其他任何人得知）当修复错误或添加功能时，代码是否被破坏了。 TDD的目标是产生更好，更周全的测试，因为在完全实现之后尝试实现完整的测试覆盖通常会产生匆忙或无意义的测试。

通常只需要写一组普通测试，并修改单个对象代码直到满足所有条件即可。

### 日志

-----

#### 日志会给出正在运行的程序的各种信息。

测试程序中，日志可以使普通状态数据，用来显示程序运行过程。

没有调试器时，日志可起到监测程序行为对的作用。 Java 的日志包（`java.util.logging`）设计相当糟糕。大多数人会选择其他的替代日志包。如 *Simple Logging Facade for Java(SLF4J)* ,它为多个日志框架提供了一个封装好的调用方式，这些日志框架包括 **java.util.logging** ， **logback** 和 **log4j **。 SLF4J 允许用户在部署时插入所需的日志框架。日志输出的格式和信息，甚至输出是否正常都取决于 SLF4J 所连接的后端程序包的实现。

```java
		private static Logger log =
				LoggerFactory.getLogger(SLF4JLogging.class);
		log.info("hello logging");
```

日志系统会检测日志消息处所处的类名和方法名。但是它不保证其对错。

#### 日志等级

SLF4J 提供了多个等级的日志消息。可以按照等级来查找消息。**级别通常设置在单独的配置文件**中，因此你可以重新配置而无需重新编译。 配置文件格式取决于你使用的后端日志包实现。如 **logback** 使用 XML ，可以尝试将 **<root level =“TRACE"> **行更改为其他级别，然后重新运行该程序查看日志输出的更改情况。 如果你没有写 **logback.xml** 文件，日志系统将采取默认配置。

```java
		private static Logger log =
				LoggerFactory.getLogger(SLF4JLevels.class);
		log.trace("Hello");
		log.debug("Logging");
		log.info("Using");
		log.warn("the SLF4J");
		log.error("Facade");
```

### 调试

#### 使用 JDB 调试

Java 调试器（JDB）是 JDK 内置的命令行工具。从调试的指令和命令行接口两方面看的话，JDB 至少从概念上是 GNU 调试器（GDB，受 Unix DB 的影响）的继承者。

`>` 表明 JDB 在等待输入命令。命令 **catch Exception** 在任何抛出异常的地方设置断点（然而，即使你不显式地设置断点，调试器也会停止— JDB 中好像是默认在异常抛出处设置了异常）。

* 命令 **list** 展示了执行停止的地方，所以你通常有足够的信息得知发生了什么并修复它。

* 命令 **help** 将会告诉你更多关于 **jdb** 的用法。

* `=>` 展示了程序将继续运行的执行点。你可以使用命令 **cont**(continue) 继续运行，但是会导致 JDB 在异常发生时退出并打印出栈轨迹信息。

* 命令 **locals** 能转储所有的局部变量值。

* 命令 **wherei** 打印进入当前线程的方法栈中的栈帧信息。



#### 图形化调试器

JDB 等命令行调试器需要显式的命令查看变量状态。IBM 的 Eclipse，Oracle 的 NetBeans 和 JetBrains 的 IntelliJ 这些集成开发环境都含有面向  Java 语言的好用的图形化调试器。

### 基准测试

----

基准测试意味着对代码或算法片段进行计时看哪个跑得更快，与下一节的分析和优化截然相反，分析优化是观察整个程序，找到程序中最耗时的部分。

在像 Java 这样拥有复杂的运行时系统的编程语言中，生成可靠的数据，环境设置必须控制诸如 CPU 频率，节能特性，其他运行在相同机器上的进程，优化器选项等等。影响性能的原因有：

* **微基准测试**

* Java 虚拟机 Hotspot 也非常影响性能。
* 优化器，有时检测出创建了没使用的东西，如果优化掉了测试，将影响结果。

#### 微基准测试系统JMH

截止目前为止，唯一能产生像样结果的 Java 微基准测试系统就是 Java Microbenchmarking Harness，简称 JMH。本书的 **build.gradle** 自动引入了 JMH 的设置，所以你可以轻松地使用它。

你可以在

1. 命令行编写 JMH 代码并运行它。
2. 让 JMH 系统为你运行测试；**build.gradle** 文件已经配置成只需要一条命令就能运行 JMH 测试。

####  C/P/N/Q 模型

C：客户端执行操作的线程数量

P：并行算法使用的并行数量

N：数组的大小：**10^(2*k)**，通常来说，**k=1..7** 足够来练习不同的缓存占用。

Q：setter 的操作成本

这个 C/P/N/Q 模型在早期 JDK 8 的 Lambda 开发期间付出水面，大多数并行的 Stream 操作(**parallelSetAll()** 也基本相似)都满足这些结论：**N*Q**(主要工作量)对于并发性能尤为重要。并行算法在工作量较少时可能实际运行得更慢。

在一些情况下操作竞争如此激烈使得并行毫无帮助，而不管 **N*Q** 有多大。当 **C** 很大时，**P** 就变得不太相关（内部并行在大量的外部并行面前显得多余）。此外，在一些情况下，并行分解会让相同的 **C** 个客户端运行得比它们顺序运行代码更慢。



### 剖析和优化

-----

安装 Java 开发工具包（JDK）时会顺带安装一个虚拟的剖析器，叫做 **VisualVM**。它会被自动安装在与 **javac** 相同的目录下，你的执行路径应该已经包含该目录。启动 VisualVM 的控制台命令是：

**> jvisualvm**

运行该命令后会弹出一个窗口，其中包括一些指向帮助信息的链接。

有时必须检测程序时间花到哪里了，从而看是否可以优化那一块的性能。剖析器可以找到这些导致程序慢的地方，**其主要功能有：**

* 剖析器收集的信息能显示程序哪一部分消耗内存，哪个方法最耗时。
* 一些剖析器甚至能关闭垃圾回收，从而帮助限定内存分配的模式。
* 剖析器还可以帮助检测程序中的线程死锁。
* 剖析和基准测试的区别。剖析关注的是已经运行在真实数据上的整个程序，而基准测试关注的是程序中隔离的片段，通常是去优化算法。

**优化准则**：

* 避免为了性能牺牲代码可读性。
* 不要独立看待性能，衡量收益与工作量之间的平衡。
* 性能优化通常只对运行了长时间的大型项目有价值，不应是小项目的重要关注点。
* 运行起来程序比一心钻研性能优先级更高，运行后可用剖析器来提高效率。性能是关键因素时，在设计/开发阶段考虑性能。
* 不要猜测瓶颈在哪儿，运行剖析器！
* 无论何时有可能的话，显式的设置实例为 null 表示你不再使用它了。这对垃圾收集器是个有用的暗示。
* **static final** 修饰的变量会被 JVM 优化从而提高程序的运行程序。因而程序中的常量应声明 **static final**。

### 代码重审

------

单元测试找到明显的 bug 类型，风格检测和 Findbugs 能自动执行代码重审，从而发现额外的问题。代码重审可以作为结对编程的一部分，作为代码签入过程的一部分（另一个程序员自动安排上审查新代码的任务）或使用群组预排的方式，即每个人阅读代码并讨论之。后一种方式对于分享知识和营造代码文化是极其有益的。

#### 风格检测

开源项目中，每个人都遵循相同的风格代码是有帮助的，阅读项目代码时，不会因为风格的不同产生思维上的终端。

风格检测器有 **Checkstyle**。

#### 静态错误分析

Java 的静态类型检测——纠正基本的语法错误。

其他的分析工具——发现躲避 Javac 检测的更加复杂的 bug。

一个这样的工具叫做 **Findbugs**。本书 [示例代码](https://github.com/BruceEckel/OnJava8-Examples) 中的 **build.gradle** 文件包含了 Findbugs 的配置，所以你可以输入如下命令：

**gradlew findbugsMain**

这会为每一章生成一个名为 **main.html** 的报告，报告中会说明代码中潜在的问题。Gradle 命令的输出会告诉你每个报告在何处。

#### 结对编程

一个人驱动（写代码），另一个人重申和分析代码，同时也要思考策略，通常两人会定期互换角色。

* 分享知识和防止阻塞。
* 解决问题。

### 重构与持续集成（CI）

-----

**技术负债**：迭代发展的软件中为了应急而生的一些设计方案，从而导致设计难以理解、代码难以阅读的部分。特别是当增加新特性时，将造成麻烦。

**重构的关键**：改善代码设计，结构和可读性，但是它不能改变代码的行为。

**重构的基石**：

	1. 测试，保证重构不改变代码行为。
 	2. 自动构建，能轻松构建代码，运行所有测试。本书用的 Gradle 构建系统。
 	3. 版本控制，可回退到可工作的版本，记录重构每一步。

**持续集成**：

​	停止假设你要处理产品测试和把部署"作为最后一步"这类的事情。这么做对于在开发周期的早期发现更多问题有巨大的益处。此外，不是做大量宏大超前的计划和花费时间金钱在许多无用的特性上，而是一直都能从顾客那得到反馈。当客户不再需要其他特性时，你就完成了。这节省了大量的时间和金钱，并提高了顾客的满意度。

​	当前 CI 技术的高峰是持续集成服务器。这是一台独立的机器或虚拟机，通常是由第三方公司托管的完全独立的服务。如果你需要额外的特性如更多的处理器或内存或者专门的工具或系统，你需要付费。

​	CI 服务器起初是完全空白状态，即只是可用的操作系统的最小配置。这很重要因为你可能之前在你的开发机器上安装过一些程序，却没有在你的构建和部署系统中包含它。正如重构一样，持续集成需要分布式版本管理，自动构建和自动测试系统作为基础。通常来说，CI 服务器会绑定到你的版本控制仓库上。当 CI 服务器发现仓库中有改变时，就会拉取最新版本的代码，并按照 CI 脚本中的过程处理。这包括安装所有必要的工具和类库（记住，CI 服务器起初只有一个干净、基本的操作系统），所以如果过程中出现任何问题，你都可以发现它们。接着它会执行脚本中定义的构建和测试操作；通常脚本中使用的命令与人们在安装和测试中使用的命令完全相同。如果执行成功或失败，CI 服务器会有许多种方式汇报给你，包括在你的代码仓库上显示一个简单的标记。

使用持续集成，每次你合进仓库时，这些改变都会被从头到尾验证。通过这种方式，一旦出现问题你能立即发现。甚至当你准备交付一个产品的新版本时，都不会有延迟或其他必要的额外步骤（在任何时刻都可以交付叫做持续交付）。

### 本章小结

代码校验不是单一的过程或技术：

* 不要臆测，学会使用测试工具
* 积极学习心得测试技术。
* 你自创的可能没有现有的好用！
* 为客户提供更高的价值和满意度而不是给程序员提供自我满足度。