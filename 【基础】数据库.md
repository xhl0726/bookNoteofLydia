[TOC]

## 基础篇——常考十问

### 一、什么是存储过程？优缺点？

存储过程是一些预编译的 **SQL** 语句，是由一些 **T-SQL** 语句组成的代码块，实现一定功能，使用时调用命名。

* 数据库执行动作时，是先编译后执行的。存储过程是一个预编译的代码块，执行效率比较高。
* 一个存储过程代替大量 **T_SQL** 语句，在程序与网络交互时可以降低网络通信量，提高通信速率。
* 可以在一定程度上确保数据安全，如使没有权限的用户在控制之下间接的存取数据库。

（ **T-SQL** 是 **SQL** 的一种版本，提供标准 **SQL** 命令，且做了许多补充，只能在 **SQL-SERVER** 上使用。）

### 二、介绍一下索引，作用及优缺点？

索引是对数据库表中一或多个列的值进行排序的结构，是帮助 **MySQL** 高效获取数据的**数据结构**。

**MySQL** 数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引

* 索引加快数据库的检索速度
* 索引降低了插入、删除、修改等维护人物的速度
* 唯一索引可以保证每一行数据的唯一性
* 索引需要占物理和数据空间
* 使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能

**MySQL** 数据库用的是 **B+** 树，**Oracle** 以及 **Sysbase** 使用的是 **B-** 树。

### 三、什么是事务？

事务是并发控制的基本单位。是一个操作序列，要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。

### 四、数据库的乐观锁和悲观锁？

数据库管理系统中的并发控制的任务是保证在多个事务同时存取数据库中同一数据时，不破坏事务的隔离性和统一性，以及数据库的统一性。

乐观锁和悲观锁是并发控制主要采用的技术手段。

* 悲观锁，假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠**数据库提供的锁机制 **（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）
  * 对任意记录进行修改前，先尝试加上排它锁；如果失败，则当前查询等待或抛出异常；如果成功加锁，则对记录做修改，事务完成后解锁。
  * **MySQL** 使用悲观锁，必须关闭数据库的自动提交属性。使用 select…for update 会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。
* 乐观锁，假定不会发生并发冲突，只是在提交操作时检查是否有其他事务又修改了该数据，如果有的话，正在提交的事务会进行回滚。乐观锁的实现一般通过记录数据的版本（时间戳或者版本号都可）。

悲观锁为数据处理的安全提供保障，但是效率方面加锁机制让数据库产生额外开销，还有增加死锁的可能；另外在只读型事务中冗余；降低了并行性，一个事务如果锁定了某行，其他事务必须等待该事务处理完。

乐观锁倾向于尽可能的做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但是直接这样做可能会遇到不可预期的后果。

### 五、使用索引查询一定能提高查询的性能么？为什么？

索引需要空间来存储，也需要定期维护。每当有记录在表中增减，或索引列被修改时，索引本身也会被修改，这意味着每条记录的 INSERT,DELETE,UPDATE 将为此多付出4,5 次的磁盘I/O。

因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢。

使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况：

- 基于一个范围的检索,一般查询返回结果集小于表中记录数的30%
- 基于非唯一性索引的检索

### 六、drop、delete 和 truncate 的区别及应用场景

SQL中的**drop、delete、truncate**都表示删除，但是三者有一些差别

delete 每次从表中删除一行，同时将该行的删除记录放在 redo 表和 undo 表空间中以便进行回滚和重做。需要手动 commit 后才能生效。

delete可根据条件删除表中满足条件的数据，如果不指定则删除表中全部记录。

- **delete** 和 **truncate**只删除表的数据不删除表的结构

- 速度一般来说: **drop> truncate >delete**

- **delete**语句是dml（数据保存语言），这个操作会放到**rollback segement**中，事务commit之后才生效；如果有相应的**trigger**，执行的时候将被触发。

  **truncate** 和**drop**是ddl（数据定义语言），操作立即生效，原数据不放到 **rollback segment**中，不能回滚，操作不触发**trigger**。

  ```
  不再需要一张表时，用drop
  想删除部分数据行时，用delete，并且带上where子句
  保留表而删除所有数据时，如果和事务无关用truncate；和事务有关，或者想触发trigger用delete
  如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。
  ```

   


### 七、超键、候选键、主键、外键分别是什么

超键：在关系中能唯一标识元组的**属性集**称为关系模式的超键。一个属性或者几个属性组合在一起都可以作为一个超键，超键包含候选键和主键。

候选键/候选码/码：最小超键，即没有冗余元素的超键。

主键/主码：候选键中的一个，人为指定。数据库表中对存储数据对象赋予唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且不能为空值。

外键：在一个表中存在的另一个表的主键称为此表的外键。

### 八、什么是视图？应用场景？

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增改查，视图通常是一个表或多个表的行或列的子集。对视图的修改不影响基本表。它使我们获取数据更容易，相比多表查询。

* 只暴露部分字段给访问者，所以就建一个虚表，这就是视图。
* 查询的数据来源于不同的表，而查询者希望以统一的方式查询。

### 九、说一说三个范式----------------------------

https://blog.csdn.net/wenco1/article/details/88077279

第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

第二范式（2NF）：消除了非主属性对于码的部分函数依赖，即所有非关键字段都完全依赖于任意一组候选关键字。

第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的**传递函数依赖**则符合第三范式。

## 查漏补缺篇——概念划分

### 一、事务

### 二、并发一致性问题

### 三、封锁

### 四、隔离级别

### 五、多版本并发控制

### 六、Next-Key Locks

### 七、关系数据库设计理论

### 八、ER 图



