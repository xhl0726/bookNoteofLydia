## 算法

### 排序
#### 快速排序
模板 QuickSort(int R[],int low,int high) 找一个枢纽temp=R[low]（通常为low），ij记录low和high，在i!=j的while循环中，将大于枢纽的放右边，小于枢纽的放左边。循环结束后别忘了R[i] = temp，一次排序后调用QuickSort(R,low,i-1); QuickSort(R,i+1,high);

#### 归并排序
基于分治法，时间复杂度O（nlogn），移动速度仅次于快速排序，分为两步，找中点，将数组一分为二，分别对左右排序（递归调用自身，继续一分为二、直到所有元素排序完毕，即每个数组只有1个数，层层merge回），merge两个有序数组。
### 查找
#### 二分查找
模板 start和end两个指针，start<=end的while循环内，mid=（start+end）>>>1;判断mid是否满足需求，根据情况start右移或end左移。

### 其他
#### 桶的思想/抽屉原则
一个萝卜一个坑，n个抽屉放入n+1物品，必定有个里面放了俩。

#### KMP算法
在暴力法ptr（短）逐个匹配str（长）的基础上，若当前字符不匹配，指向ptr的指针不跳回ptr的头，而是从next[]中取出跳转的数：**已匹配的**字符串中的类似abcdddabc的“abc”串的长度。

#### SUNDAY算法
当前字符不匹配时看ptr结尾字符与str对应位置是否相同，若直接在ptr中不存在该字符则后跳一大步；若存在则寻找其在ptr中的位置，右移至ptr中的字符与其对应的位置。

#### 回溯算法+深度优先搜索
字典的所有序列、字典中的所有可能子集。

#### 动态规划 
状态和状态转移方程；定义一个状态表示子问题，找状态转移方程；大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态

贪心问题：最少硬币 d(0)=0;d(i) = min(d(i-Vx)+1),Vx表示硬币币值，i-Vx>=0

LIS：longest increasing subsequence 最长非下降子串

LCS：最长公共子串

最长回文子串

#### 贪心算法
自顶向下/自底向上（贪心算一种）/回溯/递归总结 https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode/

回溯递归的方法第一步判断终止条件，然后考虑下一层遍历怎么调用，然后考虑怎么回到当前层。


#### 滑动窗口，即双指针问题。 
模板 是在字符串S中寻找包含T的所有字符的最短字符串，思路是在S中用双指针left right初始化为0位置，闭区间[left，right]称为一个窗口，不断增大right直到满足[left,right]内满足条件，此时停止增加right，挪动left缩小窗口，直到窗口中的字符不再符合要求。每次增加left，都要更新一次结果。重复挪动right，直到right到S的尽头。时间复杂度O（S+T）空间复杂度O（S+T)

https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/

